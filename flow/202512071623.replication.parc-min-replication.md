---
id: 202512071623.replication.parc-min-replication
title: PARC 最小レプリケーション設計メモ
type: replication
created_at: 2025-12-07T16:23:37+09:00
updated_at: 2025-12-07T16:31:41+09:00
status: draft
tags: [replication-plan, coding-agent, self-reflection, multi-agent, long-horizon]
topic: PARC風の自己評価付き階層型コードエージェント最小実装計画
sources: ["arXiv:2512.03549"]
importance: medium
timebox: "90m"
related: ["202512071525.paper_note.parc-self-reflective-agent"]
owners: []
model: gpt-5o
---

# レプリケーション計画

## Goal/Scope
- PARCの公開コードなし前提で、最小構成の自己評価付き階層型コードエージェントを再現。
- 対象スケール: 5–10タスク、計50–100ステップ級のCLI完結ワークフロー（小規模データ分析 or 実装系タスク）。
- 成果: 再現用フレーム（プランナー/ワーカー/自己評価）、タスク要約フォーマット、ベースライン評価結果。

## Env/Assets
- LLM: Claude Sonnet 4.5級（同等性能の商用APIを想定）。社内/手元で入手可能な最良モデルを使用。
- ランタイム: Python 3.10+、エージェントフレームワーク（LangGraph/AutoGen/Swarmのいずれか）。
- リポ構造: `workspace/` 共有、`tasks/{id}/` 個別、`summaries/` にタスク要約。ロギングとエラー記録必須。
- 外部ツール: `git`, `bash`, 必要に応じて `python` ライブラリ（pandas, scikit-learn, lightgbm など）。

## Procedure
- 設計
  - 役割分離: Planner（分解/順序決定）、Worker（タスク実行）、Self-assessor（別コンテキストで評価）。
  - コンテキスト方針: タスクごとに新しい会話コンテキストを生成し、必要情報はタスク要約/ワークスペースで受け渡し。
  - 自己評価プロンプト: (a) 局所エラー検知 (b) 方針整合性チェック (c) 品質閾値判定 (d) 再試行/修正/中断の分岐。
  - 要約フォーマット: 入出力パス・使用手順・依存・未解決事項・品質メモ。
  - 推奨パッケージ: LangGraph (柔軟な状態遷移＋並列制御) or AutoGen (ロール別エージェント定義が容易)。ここではLangGraph前提で設計。
- 実装ディレクトリ構造（例）
  - `workspace/` 共有
  - `tasks/{task_id}/` ログ・成果物
  - `summaries/{task_id}.yaml` 要約
  - `plan.yaml` タスク列と依存
  - `orchestrator.py` グラフ定義
- 実装
  - プラン生成: ユーザ指示→タスク列を作成し保存（YAML/JSON）。依存関係と品質閾値を含める。
  - 実行ループ: タスクごとにWorkerを起動→成果物保存→Self-assessorで評価→合格なら次へ、失敗なら再試行/中断。
  - 再試行ポリシー: 最大N回、パラメータ変更ヒントをSelf-assessorが提示。致命エラーでプラン停止。
- 詳細アーキテクチャ（擬似コードイメージ）
  - 状態: `state = {plan, current_task, retries, artifacts, summaries}`
  - ノード1 Planner:
    - 入力: ユーザ指示
    - 出力: `plan.yaml` (task_id, name, deps, quality_gate, max_retries)
  - ノード2 Worker(task):
    - 入力: `task`, `summaries[deps]`
    - 手順: タスクプロンプト生成→ツール実行（bash/git/python等）→成果物を `tasks/{id}/` へ→ログを保存。
  - ノード3 Self-assessor(task):
    - 入力: Workerログ/成果物概要/品質期待
    - プロンプト例: 「エラー/未実行/品質未達は？ 分岐: {pass|retry_with_fix|halt}。必要な修正指示を具体的に。」
    - 出力: `decision`, `fix_suggestions`, `summary`（依存・使い方・未解決・品質判定）。
  - ノード4 Controller:
    - decision=pass → 次タスクへ。decision=retry_with_fix → retries++ でWorker再呼び出し。decision=halt →停止。
  - 並列性: 依存なしタスクはLangGraphの並列エッジで同時実行可（最小実装では直列でOK）。
- 具体プロンプト雛形
  - Planner: 「指示をタスク分割し、順序/依存/期待アウトプットと品質判定基準をYAMLで返せ。タスクは自律完結できる粒度に。」 
  - Worker: 「タスク説明＋依存要約を読んで成果物を作成。全操作はログし、パスを明示。終わったら結果要約を書け。」
  - Self-assessor: 「ログと成果要約を評価。チェックリスト: 実行エラー有無/期待ファイル有無/品質基準満足?/リークや手順逸脱? 出力は decision(pass|retry_with_fix|halt) と修正案・不足点。」
- 失敗・逸脱の扱い
  - 実行エラー/期待ファイル欠如→retry_with_fix。
  - 品質閾値未達（例: CV R2 < 0.7）→パラメータ探索指示を返しretry。
  - 致命条件（資源不足・論理破綻）→haltでユーザ介入。
- 検証
  - ベンチ1: 小規模データ分析（例: Kaggle公開小データでCV実施）。リーク検知や再試行が働くか確認。
  - ベンチ2: 実装タスク（アルゴ探索/パズル小規模版）で計画修正と自己評価の効果を観察。

## Metrics/Acceptance
- 完遂率: タスク列を中断なしで完了する割合。
- 再試行成功率: 自己評価で検知→再試行し成功したケースの割合。
- 品質指標: ベンチごとの目標メトリクス（例: CV R2 ≥ 人手ベースライン、探索課題でスコア改善）。
- 工数: 自動実行時間、LLMトークンコスト、再試行回数。

## Risks/Mitigation
- リスク: 自己評価が専門的ミスを見逃す（例: 物理シミュのセル処理）。対応: ドメイン別チェックリスト/テンプレを組み込む。
- リスク: 再試行無限ループや過剰コスト。対応: 再試行上限、コスト監視、早期中断条件。
- リスク: 外部ツール未発見で性能頭打ち。対応: Plannerにツール探索ステップを追加、既知有力ツールのヒントを初期プロンプトに入れる。
- リスク: 大規模モデルへの依存。対応: モデル抽象化インターフェイスを設け、落とせる代替モデルでの動作確認。

## Next Actions
- フレームワーク選定と最小PoC実装（3役分離・要約ファイル生成・再試行分岐）。
- 自己評価プロンプト策定（局所エラー/方針整合/品質閾値）とタスク要約フォーマットの固定。
- ベンチケース2種を用意し、完遂率・再試行成功率を測定。閾値と再試行上限をチューニング。
- 成果と課題をレポート化し、次の拡張（外部ツール探索、自動計画再構成）を計画。
